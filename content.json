{"posts":[{"title":"Charles安装、抓包HTTPS、IOS证书安装","text":"Charles简介Charles是一个HTTP代理服务器,HTTP监视器,反转代理服务器，当浏览器连接Charles的代理访问互联网时，Charles可以监控浏览器发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括request, response和HTTP headers （包含cookies与caching信息）。 一、下载地址：https://www.charlesproxy.com/1.选择对应的操作系统2.点击 DOwnload a free trial 进行下载 3.安装成功后，打开Charles的主页 二 Web 抓取HTTPS协议虽然现在Charles能够直接抓包了，但是https协议的报我们是抓取不了的，需要安装SSL证书才可以Charles配置操作如下：2.1，点击顶部菜单栏【Help】–&gt;选择【SSL Proxying】，点击【install Charles Root Certificate 】安装Charles根证书即可；2.2 点击安装证书 -&gt; 本地计算机 -&gt; 将所有证书都放到下列储存 -&gt; 点击下一步完成即可2.3 设置HTTP/HTTPS协议端口Proxy -&gt; SSL Proxying Settiongs 在弹出选项卡中，勾选【Enable SSL Proxying】点击【add】添加以下Host和Port 1. *：* 2. *：443 3. *：80 解释： 在Host输入【*】表示接收任何主机 80是http协议的默认端口 443是https协议的默认端口 2.4 打开抓取web端设置Proxy -&gt; Windows Proxy 勾选中即可2.5 访问 www.baidu.com 能够抓取到接口并且接口下有数据表示成功 注意：如果接口下抓取是unknown表示失败 1. 协议未配置 2. 证书未安装 3. 防火墙未关闭 三 Charles手机抓包证书安装(IOS)App抓包Charles抓包不仅仅可以抓取来在电脑端的HTTP请求，也能够抓取来自App发出的HTTP请求，但是手机抓包需要在电脑端配置下，并且同时需要手机和电脑在同一网络下并且手机VPN也需要关闭 3.1 端口号设置 Proxy -&gt; Proxy Setting 默认端口号 88883.2 查看自己IP地址和端口号和下载证书网址Help -&gt; SSl Proxying -&gt; Install Charles Root Certificate on a mobile Device or Remote Browser3.3手机端设置：1，打开手机的设置页面；2，选择【无线局域网】；3，IOS点击连接的WIFI后面的感叹号，安卓应该是长按连接的WIFI；（注：这里主要以IOS为例）4，点击【配置代理】–&gt;【手动】；5，输入本机【IP地址】以及【端口号】，根据自己情况合理配置；6，点击【存储】再次说明：服务器IP和端口号需要用到自己的IP和Charles上设置的端口查看方法：Help -&gt; SSl Proxying -&gt; Install Charles Root Certificate on a mobile Device or Remote Browser（步骤3.2 有截图）3.4 检验代理配置是否成功打开浏览器验证下手机请求，当我们看到Charles里能抓到这个连接，就说明配置没问题，看到unknown，这个不要紧，那是我们没有安装针对手机端的证书，下面继续我们手机端HTTPS证书安装抓取手机HTTPS协议通过上面的设置，虽然来自我们手机端的Http协议请求可以抓取到，但是HTTPS协议的包是不能抓取的，需要安装配置证书才可以，现在手机上大多数都已经切到https很少由http协议的了 3.5 Charles配置：手机打开浏览器输入 chls.pro/ssl,如下提示，点击允许（如果下载失败，请更换浏览器重新在下）3.6 进入设置 -&gt; 描述文件与设备管理 -&gt; 点击未安装的证书进行安装3.7 安装成功后需要在 通用 -&gt; 关于本机 -&gt; 证书信任设置 中勾选Charles证书（针对于IOS手机）最后，重新打开charles，手机访问网页/app就可以了 注意事项：手机和电脑需要在同一网络下手机VPN需要关闭不同电脑对应不同证书，所以说你连接其他电脑需要重新下载手机证书如果抓出来的接口显示Unknown可以把防火墙关闭,再打开charles重新抓取 【转载自CSDN,作者:qq_46022251】https://blog.csdn.net/qq_46022251/article/details/121653287","link":"/2023/02/06/Charles%E5%AE%89%E8%A3%85%E3%80%81%E6%8A%93%E5%8C%85HTTPS%E3%80%81IOS%E8%AF%81%E4%B9%A6%E5%AE%89%E8%A3%85/"},{"title":"K8s常见命令","text":"K8s常见命令篇kubectl命令Tips: 万物可加|grep 'xxxx_keyword'对结果过滤 1.命名空间章 namespace :12345678910111213141516171.1 查看所有命名空间 kubectl get namespace==&gt; 缩写:kubectl get ns # kubectl get ns [env-hotfix-v2-66-1] -o json &gt; tmp.json # kubectl get ns [env-hotfix-v2-66-1] -o json &gt; /tmp/[env-hotfix-v2-66-1].json # kubectl replace --raw &quot;/api/v1/namespaces/[env-hotfix-v2-66-1]/finalize&quot; -f /tmp/[env-hotfix-v2-66-1].json1.2 查看命名空间详情 kubectl describe namespace xxx 1.3 删除指定命名空间 以及下面所有的pod kubectl delete ns [env-feature-xxxxx] eg:kubectl delete ns env-hotfix-v2-66-1 eg:kubectl delete ns env-hotfix-v2-66-1 --force --grace-period=0 1.4 创建命名空间 kubectl create ns [env-feature-xxxxx] 2. 服务章 services : ( 弹性伸缩概念 Service 1: n Pods) 1234567891011122.1 列出K8s内——所有服务services kubectl get services ==&gt; 缩写:kubectl get svc2.2 列出K8s内——[指定命名空间内]——所有服务services kubectl get services -n [env-feature-xxxxx] kubectl get svc -n [env-feature-xxxxx] |grep mysql2.3 等价于: 列出——所有 namespace ——所有容器pods===&gt; kubectl get pods --all-namespaces ===&gt; kubectl get pods --all-namespaces -o wide 3. 容器章 pods :1234567891011123.1 列出K8s内——所有容器——pods kubectl get pod3.2 列出K8s内——所有容器pods——并显示详细信息(ip网络信息) kubectl get pods -o wide 3.3 列出K8s内——[指定命名空间内]——所有容器pods kubectl get pods -n [env-feature-xxxxx]3.5 列出K8s内——[指定命名空间内]——单个指定pods kubectl get pod [pod_name] kubectl get pod [pod_name] -n [namespace_name] 4. 容器日志章 logs : 4.1 group pods ≈ service 123456784.1.1 持续监听日志——[指定命名空间内]——指定标签Lable(应用名称)——一套应用容器组的所有pods日志 kubectl logs -n [env-feature-xxxxx] -l app=[ceres-moduleName] -f4.1.2 持续监听日志——[指定命名空间内]——指定标签Lable(应用名称)——一套应用容器组的所有pods日志——并过滤查询关键字 kubectl logs -n [env-feature-xxxxx] -l app=[ceres-moduleName] -f | grep 'xxxx_keyword'4.1.3 从现在起实时滚动日志持续输出,并展示最近的10行历史日志 kubectl logs -n [env-feature-xxxxx] -l app=[ceres-moduleName] -f --tail=10 | grep 'xxxx_keyword' 4.2 single pod 123454.2.1 持续监听日志——[指定命名空间内]——指定容器pod名称 kubectl logs -n [env-feature-xxxxx] [ceres-moduleName-pod_random_num] -f4.2.2 持续监听日志——[指定命名空间内]——指定容器pods名称——并过滤查询关键字 kubectl logs -n [env-feature-xxxxx] [ceres-moduleName-pod_random_num] -f | grep 'xxxx_keyword' 5. 容器内部执行命令章 exec :123456785.1 进入 指定命名空间 指定mysql容器 执行shell/bash命令 kubectl exec -it -n [env-feature-xxxxx] [mysql-pod_random_num] -- sh kubectl exec -it -n [env-feature-xxxxx] [mysql-pod_random_num] -- bash eg:kubectl exec -it -n [env-feature-xxxxx] mysql-5b9c45bb96-tggll /bin/bash#eg:kubectl exec -it -n [env-feature-xxxxx] [mysql-pod_random_num] mysql -u root -p5.2 组合多管道pod名称传参exec,进入内部执行 kubectl exec -it -n [env-feature-xxxxx] $(kubectl -n [env-feature-xxxxx] get pods -l app=mysql -o=name) -- sh 6.查看node / pod 的信息:kubectl describe123456.1 查看node描述： kubectl describe node [node_name]6.2 查看pod描述： kubectl describe pod [pod_name] -n [namespace_name] 额外扩展1 - 查看集群信息:kubectl cluster-info123456&gt; kubectl cluster-infoKubernetes control plane is running at https://cls-xxxxxxxx.ccs.tencent-cloud.comCoreDNS is running at https://cls-xxxxxxxx.ccs.tencent-cloud.com/api/v1/namespaces/kube-system/services/kube-dns:dns-tcp/proxyTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. 额外扩展2 - 查看各组件信息:kubectl get componentstatuses12345678&gt; kubectl get componentstatusesWarning: v1 ComponentStatus is deprecated in v1.19+NAME STATUS MESSAGE ERROR controller-manager Unhealthy Get &quot;http://127.0.0.1:10252/healthz&quot;: dial tcp 127.0.0.1:10252: connect: connection refusedscheduler Unhealthy Get &quot;http://127.0.0.1:10251/healthz&quot;: dial tcp 127.0.0.1:10251: connect: connection refusedetcd-1 Healthy {&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;}etcd-0 Healthy {&quot;health&quot;:&quot;true&quot;} 额外扩展3 - kubectl所有帮助指令 kubectl –help 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100kubectl用于控制Kubernetes集群管理器。更多信息请访问:https://kubernetes.io/docs/reference/kubectl/overview/Basic Commands (Beginner):基本命令(初学者): create Create a resource from a file or from stdin. 从文件或stdin中创建资源。 expose Take a replication controller, service, deployment or pod and expose it as a new 获取一个复制控制器、服务、部署或pod，并将其公开为一个新的Kubernetes服务 Kubernetes Service run Run a particular image on the cluster run在集群上运行一个特定的映像 set Set specific features on objects set设置对象的具体特性 Basic Commands (Intermediate):基本命令(中级): explain Documentation of resources 资源文档 get Display one or many resources 显示一个或多个资源 edit Edit a resource on the server edit编辑服务器上的资源 delete Delete resources by filenames, stdin, resources and names, or by resources and label selector delete按文件名、stdin、资源和名称或按资源和标签选择器删除资源Deploy Commands:部署命令: rollout Manage the rollout of a resource rollout管理资源的滚出 scale Set a new size for a Deployment, ReplicaSet or Replication Controller scale为部署控制器、复制集控制器或复制控制器设置新的大小 autoscale Auto-scale a Deployment, ReplicaSet, or ReplicationController autoscale自动缩放Deployment、ReplicaSet或ReplicationControllerCluster Management Commands:集群管理命令: certificate Modify certificate resources. certificate修改证书资源。 cluster-info Display cluster info cluster-info显示集群信息 top Display Resource (CPU/Memory/Storage) usage. top显示资源(CPU/内存/存储)占用率。 cordon Mark node as unschedulable 将节点标记为不可调度 uncordon Mark node as schedulable 将节点标记为可调度的 drain Drain node in preparation for maintenance drain排水节点，为维护做好准备 taint Update the taints on one or more nodes taint更新一个或多个节点上的污点Troubleshooting and Debugging Commands:故障处理和调试命令: describe Show details of a specific resource or group of resources 描述显示特定资源或资源组的详细信息 logs Print the logs for a container in a pod logs打印pod中容器的日志 attach Attach to a running container attach附着在运行中的容器上 exec Execute a command in a container exec在容器中执行命令 port-forward Forward one or more local ports to a pod port-forward将一个或多个本地端口转发到pod proxy Run a proxy to the Kubernetes API server proxy向Kubernetes API服务器运行代理 cp Copy files and directories to and from containers. 在容器中拷贝文件和目录。 auth Inspect authorization 检查授权 debug Create debugging sessions for troubleshooting workloads and nodes 为故障排除工作负载和节点创建调试会话Advanced Commands:先进的命令 diff Diff live version against would-be applied version diff实际版本与潜在应用版本的差异 apply Apply a configuration to a resource by filename or stdin 通过文件名或stdin将配置应用到资源 patch Update field(s) of a resource patch资源的更新字段 replace Replace a resource by filename or stdin replace用文件名或标准输入替换资源 wait Experimental: Wait for a specific condition on one or many resources. 实验性:等待一个或多个资源上的特定条件。 kustomize Build a kustomization target from a directory or a remote url. 从目录或远程url构建一个kustomize目标。Settings Commands:设置命令 label Update the labels on a resource label更新资源标签 annotate Update the annotations on a resource 注解更新资源的注解 completion Output shell completion code for the specified shell (bash or zsh) 输出指定shell的shell补全代码(bash或zsh)Other Commands:其他命令 api-resources Print the supported API resources on the server API -resources打印服务器上支持的API资源 api-versions Print the supported API versions on the server, in the form of &quot;group/version&quot; 打印服务器上支持的API版本，格式为&quot;group/version&quot; config Modify kubeconfig files config修改kubecconfig文件 plugin Provides utilities for interacting with plugins. plugin提供与插件交互的实用程序 version Print the client and server version information version打印客户端和服务器版本信息","link":"/2023/02/10/K8s%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"},{"title":"Kong&#x2F;Konga - Docker容器化安装","text":"1.0 安装kong + postgresDB1docker network create kong-net 1docker pull postgres:latest 123456docker run -d --name kong-database \\ --network=kong-net \\ -p 5432:5432 \\ -e &quot;POSTGRES_USER=kong&quot; \\ -e &quot;POSTGRES_DB=kong&quot; \\ postgres:latest 压缩版：docker run -d --name kong-database --network=kong-net -p 5432:5432 -e &quot;POSTGRES_USER=kong&quot; -e &quot;POSTGRES_DB=kong&quot; postgres:latest docker pull kong:latest 12345docker run --rm \\ --network=kong-net \\ -e &quot;KONG_DATABASE=postgres&quot; \\ -e &quot;KONG_PG_HOST=kong-database&quot; \\ kong:latest kong migrations bootstrap 压缩版：docker run --rm --network=kong-net -e &quot;KONG_DATABASE=postgres&quot; -e &quot;KONG_PG_HOST=kong-database&quot; kong:latest kong migrations bootstrap 1234567891011121314docker run -d --name kong \\ --network=kong-net \\ -e &quot;KONG_DATABASE=postgres&quot; \\ -e &quot;KONG_PG_HOST=kong-database&quot; \\ -e &quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot; \\ -e &quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot; \\ -e &quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot; \\ -e &quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot; \\ -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \\ -p 8000:8000 \\ -p 8443:8443 \\ -p 8001:8001 \\ -p 8444:8444 \\ kong:latest 压缩版：docker run -d --name kong --network=kong-net -e &quot;KONG_DATABASE=postgres&quot; -e &quot;KONG_PG_HOST=kong-database&quot; -e &quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot; -e &quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot; -e &quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot; -e &quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot; -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; -p 8000:8000 -p 8443:8443 -p 8001:8001 -p 8444:8444 kong:latest 部署成功后，可以访问http://{ip}:8001/检查是否正常运行 2.0 安装监控 Konga1docker pull pantsel/konga:latest 方案1 konga1docker run --rm pantsel/konga:latest -c prepare -a postgres -u postgresql://kong:@172.18.0.1:5432/konga 1234567docker run -p 1337:1337 \\ --network kong-net \\ --name konga \\ -e &quot;NODE_ENV=production&quot; \\ -e &quot;DB_ADAPTER=postgres&quot; \\ -e &quot;DB_URI=postgresql://kong:@172.18.0.1:5432/konga&quot; \\ pantsel/konga 压缩版:docker run -p 1337:1337 --network kong-net --name konga -e &quot;NODE_ENV=production&quot; -e &quot;DB_ADAPTER=postgres&quot; -e &quot;DB_URI=postgresql://kong:@172.18.0.1:5432/konga&quot; pantsel/konga 方案2 kong-dashboard1docker run --rm -p 8080:8080 --network=kong-net pgbi/kong-dashboard start --kong-url http://kong:8001 http://{konga-ip}:1337/","link":"/2023/02/06/Kong-Konga-Docker%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%89%E8%A3%85/"},{"title":"Linux 磁盘挂载 （阿里云数据磁盘）","text":"参考链接 https://blog.csdn.net/ju_362204801/article/details/122873049 一、查看挂载之前的情况1、检查现在磁盘情况使用 df -h 命令来查看一下磁盘情况上图就是我没对单独购买的硬盘进行挂载之前用 df -h 查看的情况 可以看到，没挂载之前确实是只显示了一块40G的硬盘，没显示另外一块40G的硬盘 2、查看硬盘个数及分区使用 fdisk -l 命令来查看一下硬盘个数和分区 从上图可以看到2块硬盘都在 一块是 /dev/vda 这一块有分区 另外一块是 /dev/vdb 这一块没分区 你买了以后，两块硬盘就都在的，只不过是另外一块，你没设置分区挂载，还不能用 所以，下边我们操作一下分区、挂载 二、进行分区挂载1、使用 fdisk /dev/vdb 命令进行分区 2、再次查看磁盘个数及分区 fdisk -l 发现 最下面比刚才多了一个分区 3、格式化新分区使用命令 mkfs.ext3 /dev/vdb 来格式化新分区（使用ext3扩展文件系统） 4、创建挂载目录cd / 进入最外一层根目录，在根目录下 使用 mkdir 命令来创建一个你想要的新目录，我这里新目录取名为extramkdir extra 5、挂载分区到刚才创建的目录使用 mount /dev/vdb /extra/ 命令进行挂载然后再次 df -h 看一下，就可以看到新的硬盘分区已经挂载上去了 lsblk -f 命令可以列出文件系统块设备，且能显示设备的 UUID 值。 123456[root@iZwz9exnhbzxes54x0ca6lZ ROOT]# lsblk -fNAME FSTYPE LABEL UUID MOUNTPOINTvda └─vda1 ext4 aa2763ec-3885-4ef2-ba3c-76bbd5f1cb79 /vdb ext3 fcdefb8d-eb6d-4669-afe9-0e72c145080e /data 6、设置开机自动挂载使用命令 vim /etc/fstab 把 /dev/vdb /extra ext3 defaults 0 0这个内容写进去，然后保存 用命令 reboot 重启一下服务器就ok了 7.取消挂载取消目录占用 12fuser -k /file1fuser -k /dev/sdb1 取消挂载点 12umount /file1umount /dev/sdb1","link":"/2023/02/06/Linux-%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD-%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%B0%E6%8D%AE%E7%A3%81%E7%9B%98%EF%BC%89/"}],"tags":[{"name":"https proxy","slug":"https-proxy","link":"/tags/https-proxy/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"WebDav","slug":"WebDav","link":"/tags/WebDav/"}],"categories":[{"name":"charles","slug":"charles","link":"/categories/charles/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/categories/Kubernetes/"},{"name":"WebDav","slug":"WebDav","link":"/categories/WebDav/"}],"pages":[{"title":"about","text":"Java Development EngineerTechnology Stack: Language : JavaSE，JavaEE，Golang，Pythone IDE : Eclipse，IntelliJ IDEA，Goland，Pycharm Version Controller : Maven，Gradle，SVN，Git，GoMod Linux，Nginx，Tomcat，Jenkins， SQL Databases : MySQL， NoSQL Databases : Redis，MongoDB， Dubbo，ZooKeeper，SpringCloud，Grpc，Gorm Framework : Spring ，SpringMVC ，SpringBoot，MyBatis，BeetSql Html Template : Jsp，FreeMarker，Thymeleaf，Beetl JavaScript，JQuery，AJAX，JSON，RestfulApi Shiro，EasyUI，LayUI，NodeJS ，Vue，Bootstrap。 扎实的 Java 语言基础，深入了解常用数据结构、设计模式、多线程、IO、JVM 内存模型，并发编程技术。 熟练掌握 Spring、SpringMVC、MyBatis、SpringData JPA，SpringBoot 开源框架并阅读过核心源码。 熟练运用 Dubbo RPC 通信框架，SPI 扩展实现，Zookeeper注册中心的分布式服务注册和发现、Disconf 配置中心。 熟练运用 SpringCloud 微服务体系，Consul/Eureka 注册中心，Feign 远程调用、Gateway 网关、Sentinel 服务熔断降级。 熟练运用 MySql 数据库进行数据处理和分库分表，了解 innodb 引擎、MVCC 机制及提供可靠慢 Sql 优化方案。 熟练运用 Redis 缓存中间件及其持久化方案、删除策略、Redis 集群模式、预热、雪崩、击穿、穿透等策略。 熟练运用 RocketMQ、Kafka 等消息中间件，进行系统解耦，削峰填谷，异步通讯，实时海量数据等处理。 熟练运用高级数据结构与设计模式，对时间空间复杂度进行优化，扎实的算法功底，了解 JVM 内存和 GC 回收策略及调优。 熟练运用 Jenkins、Docker、K8s 进行容器编排和自动化构建部署，运用 Linux、Arthas 基本命令排查线上问题能力。 熟悉分布式系统的限流、容错、降级等高可用、高并发的治理方案和数据一致性协议，分布式锁及分布式事务控制。 熟悉 Zookeeper 服务配置，集群选举机制和分布式锁的实现。运用分布式调度框架 Elastic-Job，集群模式问题处理。 熟悉 Tomcat 工作原理，对其进行深入分析和性能优化，理解 Nginx 线程模型和性能优化，动静分离，负载均衡等配置。 了解 HTTPS 安全通信协议，了解前端相关知识 JS、JQ、AJAX、RESTful、Node.Js、Vue。","link":"/about/index.html"}]}